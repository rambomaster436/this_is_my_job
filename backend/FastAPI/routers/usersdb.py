#Api for users 

#In this case of api we can to separe if we want for become it more andarstable we could become in 2 apis differents for users and for user
#REMEMBER TO RUN A SERVER YOU NEED TO PUT THE UVICORN IN THE FILE THAT YOU GONNA TO USE

#user DB API ##

#To release an exceptions we need also import HTTPException that exist already in fastapi so we can to use already
from fastapi import APIRouter, HTTPException , status # we import status too, and inside the status we can cal already to the codes or if we want a little more beautifull we call to status in responses isntead of 404 {status.answer_code_404....: ...}
#from fastapi.encoders import jsonable_encoder #here we import from fastapi.encoders jsonable _encoders to safe that the datas sent to the server are coded 

#we import the user class from db.models.user what is from that class is
from db.models.user import User #this we import for replace the deleted beforely and with this we could to continue working how an entity is well that you created a directory where you go adding a fichero with every entity that we manage because so it's much easier or even with more directories inside because of that way all quiet structured of this way we reflex of some one form better how we'd work already with a system of data base saying there's an entity that are users and other wntity could be products and so we dont let it already inside the fichero like we had it before that is more cutre with that we've this and now our data base is empty then we think that the 1rst that should to make is to implement the operation that be capable of to start to put in users in the data base that operation we'd it already that was the operation post that is under get operation and up of put operation this that we see there with the status_code that we imported that we've from fastapi that status and inside of the status we could to call already to the codes or if we want that we wanna can to let a little more beautiful then we come there up to status and we call to status in the part of responses {status...} 

#we import from db.client to how we call to our connection client db_client 
from db.client import db_client #this was already a connection to our data base the we gonna see how we can to work with that data base then we go by what was our operation post in the post operation under get oper. and up of put because the post oper. is what it encharged of to work with the insercion of data base  

#we import the operation for give back an user that to perform that transformation #also we import users_scheme
from db.schemes.user import user_scheme, users_scheme #we import from db.schemes.user the operation that makes us the change that is user_scheme and we'll make in the new_user = to the what returned us our data base all the called db_client.local etc to this result that is the item of data base we pass to our operation user_scheme is to add this imported user_scheme(db_client.etc)

#we import the ObjectId from bson to create an object id ObjectId is the class that represent to id object and is in bson and once we've this we'd capable of to create the called an id object and the way in what we create an id object is simply we've that to call to id object in the path and the query insetead of id (, ObjectId( passing it the id )) and ready once created in the 2 the objectId is the critery but now in the part of post operation in teh part of new_user  = ..... find_one({ "_id": id this part id change a little}) that is what we the calling user_dict that we were it making to our operation generic user_search of down that had a key that would be str well it's no already why to be a string by that we delete the str of key: str also the : thenwe even could to say that that operation is generic and it's already so in some one case it reach to that operation a string in others cases ite reach to it an id object but in any one of the cases we'll can to perform the searchwe gonna test now these operation in the thunder client we go to the mongo db file in the document the users just inserted to our data base and to search by example and we pick an id or be of the "_id":{ "$oid": "this part we pick up"} because we now theorically how with that critery we could to call to a nwe operation it encharge of to search we gonna open the of put operation in Body Json and we delete what was in there inside we gonna open that in a new tab or be we click left in the historial of operation in the put and we select open in a new tab and it gets open remember taht we're making this in thunder client and we change to get operation we said that /userdb in the thunder client to search that brouth us but before we see the error inside of our server because it's not working well in our case i the line 55 appear in our terminal before of the line that appear of the operation or error line and before the line appear the file that is bad with all its direction the error is in operation get("/", response etc ) after the user_data_base = in that part of the return user_scheme(etc) in the terminal says us that the answer is not iterable and is what in there we put response_model=list(User) instead of [] in the list(User) or be we were not representing a list in there because the list it represent so [] and there it gets run already and there if we test the called and we send in the get operation of client with the Body Json vacume we're testing a call to all and when we send it the /userdb we get all the users sent beforely in the post but now we know that if we called with / and after the id of the user generated in the data base or be that of $oid or after with a query we passed it the useretc/the $oid id and we send it we get that only user or whom has that id in the Response of thunder client it's been capable of to find our id of the under of users_data base get("/",res...) of return all of there making the user_search or be the of under berfore told get("/") or be the get("/{id}) the path by the own ObjectId then we've already the operation of insertion for search everything that is the get("/") and we've already the operation of query for go searching by id lack to us a pair of operations we've the operation delete and we've the operation of update put we go 1rst with delete that is a little more fast for the operation of delete 
from bson import ObjectId

#now copied the router of products we change the /products by userdb equal in tags and now we gonna say what our documentation it puts in already in userdb then of some one form if if we call now in .get("/users") to just "/" it gonna make us already usersdb now the /userdb/{ID} equal que we'd in products it we put just the "with just/{ID}" now already by defect gonna run all on this path the userdb 
#we dont need already no to start it by here because we've already a router in the main file 
#we put with status in response remember if we dont remember exactly the code equal to put it in clear in the parts of status like in post raise well we can to make it using the status.etc from response status_code= instead of 404 the status.hhttetc and in the rest tht we want
router = APIRouter(prefix="/userdb",tags=["userdb"] ,responses={status.HTTP_404_NOT_FOUND: {"message": "not found"}}) #FastAPI() is a class 

#we dont want this now by that we delete it and in the part of the Users_datetc we delete all the of inside []for what it doesnt fail but with that in there dont gonna have users in here inside we gonna start to work with the entity that we've created in the model of models user that it calls users so what we'll have that to make if we wanna use it form this fichero is to import it and for that we put in the up we import from db.models and inside of models we put the name of the fichero  from db.models.user and we import User claser or be User what is what we created inside user
#we've here this entity, this is a model that we've for our user is a model of user that allow us represent an user that has an ID a name etc all the inside class, inside our data base or be the db file we gonna create a model folder that we gonna call models because there we gonna represent which are thos entities of model with what we gonna work to level de class from our fastapi from python and inside models folder we create a new fichero called user.py and inside this fichero we gonna copy all this class
#Model object encharge of understand that all t|he datas that pass to us are what have typed and of to become the json in an user
#defining entity user is with entity class User(): where in the part of down it find the parameters
#class User(BaseModel): #The BaseModel is giving us the capacity to create an entity is how if we would be creating an estructure of user type that hase the parameter of down an this BaseModel gonna have by inside a very concret mechanism that allow that we create it, try with it 
    #we're typing name as a string because is help when we work with a object user type then the name has that to be text string no other also serve for all the rest
    #equal that we have this formation for users we can do some seemed also but for some that give back objects
    #ID: int  #we put the ID identificador Ãºnico de cliente mediante el cual un anunciante elige identificar a un usuario que visita su sitio web. to identify and this is in path
    #name: str
    #surname: str
    #url: str
    #age: int


#@router.get("/usersjson") #for what go in in main normally we 
#async def usersjson(): #with async we become def of a funtion sincrona to a funtion async #ever that we call to a server the operation that it execute have that to be asynchronous
    
    #return [{"name": "robetr", "surname": "ray", "url": "https://mouredev.com/python.queti", "age":12},
            #{"name": "rambo", "surname": "quispe", "url": "https://lavacalola.com/python.import", "age":15},
            #{"name": "julio", "surname": "mamani", "url": "https://lavacaachorada.com/python.that is the same", "age":18}] #also work with string but someone symbols dont reknow them

#and the path that we that we'd defined how ("/users") ("/user") that we'd all down all these we gonna simply make that they difference because if we get run this in really we'd have exposed in the same path 2 apis differents then it gonna be an api that we gonna call usersdb
@router.get("/", response_model= list[User], status_code= status.HTTP_404_NOT_FOUND) #by some one reason when we put the answer code when we do the petition get in thunder this  cant reknow the answer code by that we deleted 

#"remember the double funtions can create you problems or to do that dont reknow 'em"
#user() dont affect much
async def users(): #with async we become def of a funtion sincrona to a funtion async #ever that we call to a server the operation that it execute have that to be asynchronous
    #now we're going to return Users_data_Base
    # in this operation we wann obtain all the user of data base if we wanna obtain all the user of data base then we'd access to my data base db_client we access to .local and inside local to .users we dont must to get worng and if we call to .find() it gives back us all and what we could to make is paginar to search a collection very concret good is to say to bring us all the users it doesnt get loose to be the normal yet in this case equal that in operation post in response_model = User we specified that the response_model was User if what we wanna bring all the users in this operation surely the logic is what we wann bring is not User if not a list of user by that equal that we made in the post operation we copy all the , response_etc = and we change the User by a list(of User) remember that all the db_client.etc we must to return all that of response_metc all this we especify it because so fastapi directly validate it and also gonna it putting in directly the documentation for what we know already what it gonna give back when we wanted to give back we said that all that of here db_client.etc is an object that hasnt why to be that object of User the User object of the respose together to "/", because in data base well it's that id that is different for it we'd created that we'd the entity of user and we'd created a scheme of scheme folder file scheme a scheme that is capable of to make differents operations to help us to transform those datas of data base to the datas that we have in mind to the hour of to work with users in there what we could to makes is even in the scheme user file in all the part inside return {..} ehst we could to makeis what the dictionary in there or -> dict instead of to put dict to say it that it gives back an User we could to work so and there wouldnt have no one problem and neither wouldnt have no one problem in to work it of that way because doucl to go making the transformation one by one that if we wanna make it we put it or we practice it or it's already we there put it to dictionary how for extraerlo a bit more so what we gonna create other operation in down of user_sheme funtion of the folder scheme user file that it calls instead of user-scheme users_scheme() funtion
    #in return we call to users_scheme from schemes folder user file and to put all the rest of the operation inside users_schetc but before we import the users_etc from its file sheme folder user file and with this we've this operation here in get operation that is already capable of to return all the users imagining that we wanna make is to search only by id the operations of down of this operation get with the ids 2 more or less well equal that we've those we'd an operation user_search in its returns of those 2 the operation user_search searched us and we've it without to implement in the part of up of search_user funtion in the try: of user_searchForetc and what we've that to make to perform a user_search in really some very seemed to what we'd in the try of user_searchForetc very very seemed the operation of up user_searchForetc in really we might to make that was generic and then we now delete the Foremail only letting the rest of the name to the funtion and we gonna create a string that is Field and other that is key inside the funtion of up that we changed the name or we delete part of the name user_search(field: str, key: str): and we make it because so basely what we could to indicate in the field is we pass it the critery of searched and which is the key by what we wanna search for that we change in the user = of try: the part inside find_one({field: key}) and we delete all the operation user_search of under user_search with the try 
    return users_scheme(db_client.users.find()) #we create the class user with this with this we are indicating that all these parameters we are doig of way positional and with = we're saying that we're representing in everyone of the camps #really we can create a class and  to send the arguments how we want but in this case we have a class that is herediting a behaviour of BaseModel in this case by that are espcifying how go everythingfor what doesnt exist no doubt of how are creating the objects how you can to see in the postman the order of position of all 

#in both so in path as query the operation that has user_search of the returns now we gonna can to search by id like in down of post operation ("email", user.email) but by id of the way by id with a camp that in really is _id so what the camp we gonna say it instead of ("email" we put or be that the camp we gonna say it that is "_id") equal we make it in the 2 and what we've inside id of both query and path in the line of the funtions is that be integer but now we know that the id is a string then we modify em in both funtions lines by there ligerament and in the search_user of its returns wee'd have that to pass instead of the user.email the id in the 2 but we still we'd that to make a thing more remembering how was in data base saved that and we gonna data base and we see pushing a file of data base or in the document of user that the id of data base is not an id string we dont know how many it's already if not is some that in really it's modelled how what it understand in mongo as object id or be the "_id": { "$oid": "..." remembering that the $oid is object id } so what we've that to create an object id of this type presented some very easy simply we import from bson the ObjectId that is where in really is the class that represent the id object and once we've that we'd be already capable of to create what we call an id object how such

#path 
@router.get("/{id}")#Theparameters go in /{parameter} #and if form part of this path and we wanna try how a parameter this doesnt mean that we are calling /users/ID if no we call to /users after would call to a parameter that we must capture that iterpretate how an ID, this gonna to by an user then logically is not call it users if no to call to users

async def user(id: str): #The ID we capable of to read it here in with funtions that might to have parameters we pass it parameters with the name of the (parameter: typing the datatype)in this case (ID: int) fastapi work tipeando the datatype 
    #this id of down in this return in Objetc( this was just id ) the api that it connected to our local data base and what it did requests and what we made were consulted users saved usuarios we were capable of to update made differents things in here, the 1rst step is what in start we've already all working in local we now gonna there to the console or be if you've it off in our case continue on or be the terminal etc and if it's off we get run it and by there it gets run by other side we'd apart of our local server we'd our data base what was that is in the db folder client file like message 
    return user_search("_id", ObjectId(id))   

#query
#this get sith the ID it'll go also on / 
#here we put also the userdb an in all also in the up
@router.get("/", status_code=status.HTTP_404_NOT_FOUND)#"/user/" the same of up but without the {ID} #if we put the same /userquery/ in postman it gonna return that the values gave back are not 

async def user(id: str): #The ID we capable of to read it here in with funtions that might to have parameters we pass it parameters with the name of the (parameter: typing the datatype)in this case (ID: int) fastapi work tipeando the datatype 
       
    #Lambda return the camp ID #if we execute it gonna give back an object, and we save it in a user because we said that we dont access Users_data_Base because is in another funtion, aslo we can save of many forms how in a for and anothers etc
    return user_search("_id", ObjectId(id))

#post 
#post is for add values 
@router.post("/", response_model=User, status_code= status.HTTP_201_CREATED ) #we change the status_code instead of the number we make it with the status.answer code and we make in what lack and once done that the 1rst that we must to make is to create the operation that be able of to add user to this data base we dont gonna start by the of consultate because we've not yet datas then we gonna start by one little more complex but that we've already seen which is the dynamic to the hour of to work with this that is simply to insert it to can to work with data base we've that to import the client of data base that is inside db in the fichero called client the db.client and we import inside this client to how we call to our connection client  db_client
async def user(user: User): #the name can return to be user because we gonna add a new user in parameter we put user: User because we gonna add a new the user is the parameter and the User because we have one up
    
    #here we called to a operation that it encharged of to search users to see if it did exist already or if it didnt exist of moment then we became in comments because we gonna make how what ever it gonna put in the user to understand what we make in this case we gonna make several things the 1rst that we must to understand is what we dont gonna work with the users_dataetc by that we delete it now we gonna work with our data base and where it's is in or how we can to access to our data base is with the db_client and where we wanna save this of this fichero in our data base then we go to the data base mongodb and we go to the leaf and we go to our connection to data base and in there we've a scheme called local that is our database local ofcourse we can to create more also to work of a huge a forms since we've in there how this data base that it calls local then we gonna work on local and what we'll make in this case to the call to the data base db_client we put .local to connect to the file or data base in this case the autompleter dont gonna complete it because it's not capable of to know the fichers system or the directories system that we're gestioning inside the data base so what in there we must to put local because is how it calls there the db_client is almost in the space of replace of users_daetc
    #remember a error code 500 we cant release only the server is danger 
    #we search if really exist the user but by email and if really the result of what come by User or be the line of down = in this User is an user wel straightly this wanna say that what we've it found and if we've it found then mean that we can to follow to forward and to say the message of down line of raise, we've an user the user exist already and if not then it must to insert it and we gonna test it in thunder client sending an username and email that existed already in the same of post Body Json but when we send it it continue allowing to insert em without matter that they existed already this mean tht it's not searched well because it wanna say us that equal it's us created a new register if we see in local file of mouredev document we see the new createds that are the sames we've failed and we gonna check out why it's it insert when it doesnt should to try solve the fails of up we gonna comment the return with user_searchetc and we see in this operation post we've the user with this comes us the email and with the email we make that search in user_searchForetc and what there we make it an find_one we perform that search and it's already and to solve this problem we can also to stop the server and to come back to get run by if really it's had someone problem because how is also failing the operation of up user_search we comment those user_searchetc for ensure us of what we've all well but we can to create the operation allthouth  user_search in down of user_searchForetc funtion  without that it makes nothing 
    #when we're calling to the operation user_search_Foretc we modify because we transform just to user_search and we say it that the camp in the what we wanna search is user_search("email" and the key by what we wanna search is the own email user.email) now equal that we've all the user_search and its inside the operation that we'd in up under return users_scheme(db_client.etc) or be with the data base or be the get with{id} already of before search_user(id) in the path and the query now we gonna can to search by id in those also in the 2 we put user_search("email", user.email) but vy id of the way by id with a camp that in really is _id 
    if type(user_search("email", user.email)) == User:#we can obtain this list of users, to say user_search("passing the ID that reach by here" user.ID) with if we prove that the ID exist or not also if it's error or if has list of users#we can do a proveexample to prove that if the user exist already then we dont add and it return an error how drive of exceptions
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="the user exist already") #we can to put more parameters ,detail #with HTTPetc ww dont need return because we're releasing an exception
    
    #user_dict is a dictionary we just become the user that are going inside ina dictionary 
    user_dict = dict(user)
    del user_dict["id"] #deleting the ID of the user_dic with these 3 we've enought for what we can to insert an user so what we tested and we see if it works or not and we gonna make to let it more beautiful we said that we returned the user return user yet now would be that once that we've it already inserted in data base now if what we could to return the user but also with the ID then in the moment that we insert it in db client last... we can already to acces to the ID ).iserted_ID then we'd have already the operation of creation in data base and the ID with what it's inserted ID= we equal all the line to ID and once we've already this ID we untill could to play to search if really is this ID in data base and we can to make it well we come back to access this to make it of the way most purista that is what we just of to insert we could to assume that has inserted to the of the user(this user:etc) and that the ID is the ID to what we equal it ID yet to make it even better since we've inserted it and since we've the DI that is its single key we gonna to test if really this ID is in data base to that we've that we acces to our data base and the way to acces is coming back to the client db_client where it was in the .local that was the data base int th part of down we put all that and with the scheme .users and we search it with some one operation putting . and we found by find that we've a find_one() and we pass it (what we've that to search by that we create how a json {and we say it which is the critery of search what is an "ID": and the ID that it's that to search what is what ended of return the own data base or be ID}) and now what we've here is the new_user in down we equal all to new_user

    #here we call to the data base and we put the . to call to the data base and it when we call to the local it doesnt complete it because it's not capable of to know the fichers system or directories system that we're gestioning inside the data base so what we put local because is hoe it it calls so 
    id = db_client.users.insert_one(user_dict).inserted_id #we inside local the file  of DB we see that what we have in local startup_log gonna have some one documents gonna a serie of directories #we gonna create the local the called my own scheme of data base and this scheme we call it users .users by example because there we gonna save users and we see that it's not created in the local but we gonna wannna work with a scheme that it calls users well what we've that to make there is to insert an user what was what reached me in the request in post the async def user user:User so what now yes we gonna see when we put a . what this autocomplete us that we've an insert_many inser etc insert_many if we wanna insert many reqisters inse_oneif we wanna inser only one in this case we wanna insert one and what we wann insert is our user our .insert_one(user) of the form in what it's modeled is pydantic we know already of some one way in the user file the library BaseModel allowed us gertionate modells to level entity that allow us to work very fast with a class that we can to transform fastly in a dictionary in a json what is with what it work in the petitions http and what it work also in mongodb that we said already that all what we gonna save here in true is a json what you gonna find in mongodb to level of scheme what we have in this line this user gonna be easy to transform in a json that is a json to the end to the just a json is dictionary it's not more that's all so what this user we gonna up to create a variable and we gonna call it user_dic = and we gonna transform the user in a dictionary dict(we pass it the user user) and well have already my user my entity user my model of user transformed ina dictionary and this'd be already what we wanna put in in this in this line instead of (user) we gonna learn how it works mongodb the usual is waht though our user we've it defined how that it's an ID an username and an email in the user file am ID we'd not have that to define it the ID has that to be an identifier single with the which it'd be some that would have that to generate or the own mongodb or what we'd have that to generate of a form single by defect mongodb every time that insert a register it gives it an single ID  so what we can to make is to refine more but this is for go more fast so what we we gonna make in up in async def user: User in that User what in true one of the camps of the model can to be an ID well we gonna say it what is optional in the user file the ID: int | None we gonna say that it can that the ID camp didnt reach us because what we wamt is directly to send it an user and an email and that it insert me it in data base we dont gonna pass it the ID because we dont gonna know it since it's an new user the ID the mongo db by defect is not an integer is a string because so it can to create singles IDs much longer and without no one problem so what we change it to string str in the user file and what can to be how we've told in the user file optional can that it doesnt reach it in the moment that we're calling tto this post of here and what we gonna make in user_dict what if we true created a dictionary and we insert it gonna end inserting the ID camp how a null in insert_one but what we want is that the user_dict it inserts it of 0 so what we gonna ensure of what in my list in my dictionary it gonna delete the camp that is ID that camp we gonna delete up yes or yes between user_dict and db_client del user_dict["ID"] because so it only gonna insert the user the username and the email and the ID it gonna to encharge of autogenerate it the own mongodb with these 3 already would be for what we can to insert an user and we test it 
    
    #new user is for find the ID that return the data base #the name of the single key the name of the camp of the single key that create mongodb by defect is not ID is _ID or be we must to replace in the find_one({_ID..}) this is some that we've that to know because it makes so authomatically but the find_one what in really gonna end finding is a json this doesnt wanna say that we end returning an user therefore we've that to end 
    #this new_user was an object of data base that wasnt sch which what we wanted give back that was this user but now we've already created an operation that is capable of to perform that transformation so what we gonna import it in up from db.schemes
    #we pass to our operation user_scheme all what returned our data base or be all from db_user.etc to this resulted that is the item of data base we pass it to our operation user_scheme our operation transform us and it create already us an object that coincide exactly with what we wanna return being what we wanted return an object of type User, this new_user in really we could end  creating in return of down an User(and we pass it here all the camps of the new_user that is a json how such **new_user and we pass it here and it end creating an object of type user that is what we're searching) and we returned already eith this we've already the operation of insert 
    new_user = user_scheme(db_client.users.find_one({"_id": id})) #this find_one in really what it gonna end finding is a json this doesnt mean that we end finding an user by the which we've that to create someone operation that be capable of to perform this transformation of what comes us of data base we've that to return to transform it in an object called user in an object of type user how such so what for it we gonna see a new concept equal that we'd the models by db folder we gonna have a new directory called schemes or be we create a schemes folder because in there we gonna have operations that be capables of to help us to work among what are the models and how it is trying these datas in data base so what the scheme with that we gonna work is with user.py or be we create other fichero inside schemes folder we call equal  but there's no one problem and what we've that to make here is with what is reaching us in this line some that we gonna search in data base and what is possible that find us the user but what this of this line gonna be a json we've that to search the form of to transform what comes us of data base to the representation of our user the User of up and what had our user is what was in user of models anda those 3 we copy in the user of scheme without the class sijmply to have it as reference so what we create a funtion inside it #once what we in thunder client 

    #another good practice in the moment that it work for havent doubts how it has resulted to dont return a null we return user in the post that has been added in the post because if it fail it returned error and in the put some seemed also we put
    #once sent the username and the email in thunder cliente then appear us a id created for the data base of way authiomatically and the answer code of the thunder client appear us the 201 has worked also in the thunder once sent appear us also the username and the email that we sent and the letters that appear in the id: "here is the the id ythat has generated mongodb  " also remember put in your programs ever id and no ID is better and the way that mongodb has aouthogenerated the id has been with with the line of id = where we insert localetc.insert_one  and we stay us with the id inserted_id and we make the tranformation of what comes already us from data base find_one and we make the transformation to our ownn object of user_scheme in the module def user_Schetc what gets correspond with the user to level of model and with all that already we created an user that has now id username etc **new_user and we give back for waht once we've created it already we know also from font that it has created and now these are the datas that has the user part that what we've it already sent but now also we've the id then that id from thunder client we cpy to a block of notes because now that we've the id gonna can already to start to work with our user we go for the mongodb and  we gonna refresh it the local file with refresh option we said that we gone to create a data base inside local and when we open the local with the > we can to find the users file because we said that that scheme it gonna calls self users and it's created a scheme that it calls users because we've it already inserted some there and what we'll have inside is a document and what it'll be that document is a amount of letters and numbers what we still dont know well what it is but what if we choose or be we click it we 'll see what the local users we've some with an id authogenerated inside "_id": { "$oid": ujwudf...} in the file remembering what by defect it create what it it calls an object id "$oid" object id the $oid id the object id that has the id authogenerated and inside what it has is the username and the email sent in thunder client so what with this we've our 1rst register in data base and if we wanna insert other we gonna create other in thunder client how the old of that way we shall to make how we puts already before and we sent it in thuder client and we gonna our data base local and in the document we we refresh it and we've already all the new documents all the new registers inside our data base is super fast super easy super authomatic but the next thing that it can us to plantear here is what if we now gonna thunder client in the post and if we now come back it to send the same username and email it'd mean what the data base gonna come back me to save other register equal that we puts because in really it's not performing noone testing in all from user_dict untill all the line of return all what reach it goes to inside it gonna save it but this might to end giving 2 registers that though it's an id different yes what the datas that it's inside are equal or be in the local data base then we'd like to test what if the username exist already in someone side then it doesnt isert it that i what we did before in the part became in comments in up of user_dict and under async def when we're trampeando what was the data base we'd an operation that it calls user_search that was capable of to search of someone form if the user existed already then by that we discoment it now the critery gonna be to search if our user exist or not for that we've the user_search in under async def user(id: int): in under of its if not found: in the def search_user(etc  ) but in really we gonna have that to define other critery what we gonna have it that to pass to that in the search user in of down the user_search(in here is an username: of type str ) and we can it to put like name to teh funtion usersearch_forUsername( ) to test if of someone form this user exist already the username in data base or better is to say not the username if no the email so what we put the name foremail instead of Forusername because 2 users yes what we've decided taht cant to have the same email then that'll bbe my critery to know if we gonna insert it or not in data base 
    return User(**new_user) ##we pass all the camps of the new user that is a json here and it end creating an object of ttype user **new_user and we returned already  with this we've already the operation of insert nos we gonna see if it works also lack us the part of to test if the user existed already for dont come back to insert taht is in the up in comment of post then 1rst we gonna make the part of to insert that is of the most complex this is almost of the most complex that we gonna see of mongo db then we gonna to our utility or be to the thunder client where we could to make calls that we can to make how if it was a client http to our api and we calls to the path that we've defined thatm is userdb in userdb file we put in where we make the petitions or calls to the sever /userdb that we put in up under import in the router and the operation that we wanna call is the post of here and we had that to call to that post with an object user and this object user we said that to this object user we gone to take off the ID because the ID didnt do lack how such so waht that user object in really is a json of the type of the user.py from schemes folder some to what we gonna pass it an username and an email so what what in the Body of under of where is the server local or the place where is the requests in the Json also we gonna say it in the Json that we gonna create a call that gonna have a pair ofa camps or be we copy the atributes of user_scheme of user file of schemes folder and we locked these atributes between {} and we delete the after the: in the 2 cases and we put it how in the validation the username that we want in the 2 cases but with "" these can to be anyone this would be the only that need our user for can insert self then we send it and we'll get the ID username and the email without problems the username is what we puts in the Json equal the email it also return the answer code 201 it has created has worked and the ID that we've is the ID that has autogenerated mongodb of the way in the ID = generated here insert we quiet us with the ID and we make the the transformation in new_user = with find_one of what comes us already from data base and we make the transformation to our own object or be user_scheme that it correspond with the user to level of model and with all that already we create an user that has now yes ID user name etc this is the new_user and we return with ** to what once we created it already we know also from frontend that it's created and now that in thunder are the datas that has the user part that we've already it sent but now also we've the ID then we that ID copied it to a block of notes because now that we've the ID we gonna can already start to work with our user then we go to the mongodb and in the local we refresh it we said that we gone to create a data base inside local and we see inside that we've already in there what we said that that scheme gone to call self users and inside we see that it's created a scheme that its name is users because we've already it inserted some there and what we've inside users in local is an document calls self Documents and what is that document is a set of characters that we dont know very well what is but what if we make click we see an {"_ID": {"$oid":"the gage back in thunder"}, the rest of what we puts} that the local users we've some with and ID autogenerated inside the "_ID": 
#put
#put is for update also to change and user by other or another elements by other we could to do a put of parameters by separed
#remember the response_model=User go to the right 1rst of the "/" #in the put we gonna return an user in the case of that we update it by that the responsetc and we say it that our put gonna receive an user or be in the funtion of here user(receive an user: User) and it gonna it to end returning searching updating etc in the parts of this funtion down now we delete the part from found= True line untill found= false we delete all that search what we made manual and by end we can to load the users_data_etc that we'd for mockear before and we gonna implement now how we could to perform an update operation of all this object so what ever what we try to make someone search try to do some that can to fail the recommendable is what we make it inside a try: and except:or inside a control of sesions very recommendable and we make it in stead of the puts beforely in the put operation and up of if not found: what we might to be in this case the if not found well that in really if fail us the operatio is what it didnt get update by that we translate the return and its content of if not found: to except: and inside the the try: we try to make the operation of search and of update in try we access to our data base or be all the db_client etc of ever remembering we delete the if not found 
@router.put("/",response_model=User, status_code=status.HTTP_404_NOT_FOUND)
async def user(user: User): #we can update the complete object or be we send it the complete user and it gonna change and user by other or by parameters by separed or be this object user accept nulls and we just modify parameters that we wants inside this user like the URL or be only send that to my operation this to do it of way more advanced this might to be well for these cases would be to use patch but patch we do not gonna use because is not an operation of the super comuns  when we gonna create an APi w'll have of all #the patch is better to update a concret part of the user and the put is better for all the user # we dont gonna use the patch because patch is an operation a little more advanced #We gonna implement a pure behaviour of a put that would be update the complete user to update the complete user we have that to put in (user : User) seemed to up if we wanna update the complete user we have that to put the user
    
    user_dict = dict(user)
    del user_dict["id"]

    try:
        #we access to our data base and we put the operation what suit us better in this case is the of search and update .find_one_and_replace because we choose this is because in really what we want is to update all the object the put is for update all the object after we've an operation also that is what it calls Patch because equal we only wanted update the email or the user name etc in the operation fin_..._replace(here we'll have that to pass which is the critery to the hour of to replace what is what 1rst we've it that to search and the way of to search it is to go to search by id equal that we made in the delete operation in find_o..._delete(in this part equal)) and the id is in this case well of the object that reach us or be the user: of funtion line well we gonna to search the id or be we search in the ObjectId(user.id) because now if that yes we'll have that to pass it the id and what we'll have that to update is what we want is what in the moment that we find thata register or be in the try: in the db_client.etc this is the register we pass to have ("_id": ...), this new user) but now to think what we made when we were inserting by 1rst time an user in user_dict= of post operation the 1rst what we made is what clear we cant to insert that object user that we ended of to put , user)in this put operation in try that is an object of model we've it that to pass to a dictionary so what we gonna this try of this put operation and we paste the user_dict =etc of up also we can make it out of the try in this operation and we create it we create a dictionary in base by example to that user of here the user of the funtion line or how the way what we know already that that user_dict = it's not why to give a fail that is some controlled we put out of the try or before and other thing that we made was we deleted the id in the part of up del user_dict etc and we put in here equal deleting the id of user_variable because the id some that cant to change basely then we in really what we've that to save is the user -dict instead of the , user in the operation of here in try: put operation remembering that the {} go of _id untill user.id) in operation replace that user_dict that we passed it is to the final is the dictionary that we've created and we delete the camp id because we dont want uptdate the id camp that we dont want that it touch in really we wanna update the rest of camps less the id the id cant update how such then if this work of inside try cool and if it doesnt work it goes by the exception and is the message of error that return to us in the case of what the of try work it doesnt pass us by the except: and we wanna return the user by that we delete the user of return of under except we can it to continue making of form purist we know already that the user in really is that that center us in the () of operation find_..._replace the user inside ObjectId but we gonna test that in really it's in data base then we gonna call t our user_search() operation in the return after except of here put op that user_etc we'd it in down that generic operation and we gonna come back to search the user and the way of to search it is well the user in really we search it by id then we've that come back it to say that what we wanna search is the camp ("_id") in the critery of user_search of here in return that we could to create an operation only to search ids but good there in return of here by to let it a little more generic why that fichero also is very small and we'd that to search it in base to the ObjectId ("_id", that is this ObjectId(id)) then now we gonna see if we can to update the user in the thunder client we test in the operation of insertion or be post and we send or we test that the user has been sent now oncce tested that the user has beend send to D B what we want is update that user ant that user sent already or be when we send the user by 1rst time it give backe all the user its id username and email that we copy it and we put in the post operation Body Json because now yes that we've it that send with id because it does lack for what 1rst it searchs it then if we go to an operation of search get operation an we stick the id gaae back like ever /the $oid we obtain the user now we gonna go to update now yes with the Body Json with 2 to update we change it hence done well this even we'd have to perform an operation to see that it doesnt exist that email already in data base whatever we could to make it many things but imagine what what we wanna make make is that the username we update for other we make a put operation but in this case we dont need to put the /$oid  because the id is also in the Body Json the 3 go in there we can even just update one of the 3 and we see that there's an error in the terminal that says id must to be an instance of ObjectId and we see that in the return we puts the id the which is nothing in this operationit's that to be user.id what we pass it and we send again and ready with that it's well
        db_client.users.find_one_and_replace({"_id": ObjectId(user.id)}, user_dict)

    except:
        raise HTTPException(status_code=409, detail="the user wasnt updated") #the errrors cant be represented so ever if no there's many ways better 
    #and ready with this return it gets update besides remeber that the id in this operation is user.id since there is where is the user and we come back to test the get the username updated but it's failed because it's returned bad the uesr we gonna make it to everb we've that user updated but we now gonna it update again but with other username we send it and we have it in the response of give back with the username updated and if we make it a get we obtain the new username and all thus worhing with the data base and if we gonna to the D B and an we refresh it or be the Documents of users folder ewith the arrow in circle well in those users we see the user updated and the other what no the replace change the complete document and the update we gonna by a concret camp to update mongodb mounted from 0 runing the local in down we've it the of mongod file runing our instance clear if we go there and we stop the instance of mongodb we come to the thunder client to make the the get of turn or be of one of our users with the $oid and we send it we see that the thunder it stay amangado or be stoped or loading because in really the data base is not and if we go to the mongodb or be the localhost connected or be we make click it gonna me to stay thinking because neither it gonna me to stay connected in change we come back to wake up it and it's already connected has already answered  
    return user_search("_id", ObjectId(user.id))
    
#delete 
#we start in delete because is some more fast for the delete operation before in the list we searched everything or be in the users_daetc but now in this case we dont have already it that to make so what all of the line from found = True untill found = False of its up we gonna delete 
@router.delete("/{id}", status_code=status.HTTP_204_NO_CONTENT) #delete of an only user #In here in no one place we're recollecting the body of this petition 
async def user(id: str): #the funtion to use is remove or method 

    #with this we test that is right if we found or i didnt find 
    #we gonna call to our data base db_client.local.users equalling it to found and there in our data base we gonna see if we've someone operation for delete when weput the . after users. appear a huge of option in those also appear operation for delete in this case we choose find_one_and_delete() this makes what its name says this can value to us enough and the way that we makes the elimination is what we dont do already the elimination by an id of type integer or in the part of this funtion user(the id is not of type integer id: int if not by a str we change it) and in really when we deleted it we think that the part of the operation delete or be the .delete() we could to complement a little and is what equal that we're giving back keep on that codes in the status_code = . in this part HTTP_404 in the post operation or keep on what the model keep on the case in the own name of the funtion line in status_code = status.the rest) well we gonna give back a case by this delete operation  funtion usert line together to id in the case that of what we delete rightly we dont gonna give back nothing because it's deleted right ly and together we paste the status_code=statusetc of post operation line and in the case of what it gets fail what we give back is the of before we puts down if not found operation the error message of return so what how is the case in the part of funtion line status we change the answer code number by 204 a no content is to say that all has gone well because is a 200 but we dont give back nothing the 204 is what there's no content  but understanding that that is how if it was well is perfect only that it gives back nothing it's deleted we dont need nothing more the found in this operation that we puts to equal = and this already by the own definition of the api of mongo what says us is what if really it's deleted it gonna return us by the find_one_etc the deleted then what we can to test is that found is empty is what it didnt delete nothing then we could to follow reusinf the found by if not and to say if we dont delete nothing send the message of return we gonna test it and we again copy a id of one of the users inserted in thunder client remembering of whoe it was and we go to thunder and equal that before in get operation we put again together to user../we put the oid and we send it bu in delete and also we can to test that the user follow staying and after we delete and we see if it continues there but in this case when we send it appear us an internal serer error 500 in delete operation and we see the error remembering that the status_code =all the rest ever must to go in the operation line and no in the funtion and we see that the error was that we didnt put the critery in find_one_etc(id) in the found line well the critery we'd have that to search it by id but it must to put {_id} we create that critery of search by the camp how it was {"_id"} that is what it save in the data base but it's no an id flat if not an : ObjectId() and we pass it to that (the id that has us reached to the calling) now with is ready and we test it in the thunder and return us the answer code 204 and when we check out in the get we see that give back the message of not found or didnt find because we deleted it then is working well we've deleted it rightly and with this we've the delete operation implemented in here and only quiet to us already an operation that is the put or update that by definition made was how an update of all the object by to follow the same the same what we gonna return in the put is an user for that we copy the of the operation post line the response_model = ..., in the case of that we update it then we go to put operation and we paste together("/", here) in operation line this is under post operation in under return User(**...) 
    found = db_client.users.find_one_and_delete({"_id": ObjectId(id)}) #remembering that this db_client.this is the direction of our data base or file of saved of our data base 

    if  not found:
        raise HTTPException(status_code=409, detail="the user wasnt deleted") #the errrors cant be represented so ever if no there's many ways better 
    
    else:
        return {"the user was delete": user}


#here we create a funntion to get save the funtion repeated of query and path or its operation
#we change instead of email by field and we add the key: str inside user_search because we delete the Foremail to become in the rewanted of up and to perform an user_search and for what it was generic the (field:str ,key: str) is for indicate it in the part of user= of try in find_one(is what we pass it the critery of search {field: and which is the key by what we wanna search  key field: key of up}) and it'd be we say more generic when we're calling to the operation old of user_search_Foretc in the part of post operation in the 1rst if type(in here first()) we just change the old user_etc by the new user_search and we say it that the camp of user_search( in the what we wanna search is "email" and the key by what we wanna search is the own email we add just "email" "email", user.email) 
def user_search(field: str, key): #this is my critery if we gonna insert it or not in data base bu before we searched it in our listed of users or be the line of down users= filter etc then it we delete it we returned inside try return that line of returnwe delete it and then we'll have that to make inside try is to have that to search if this email exist in our data base remembering also what the username of this we need to change since we're searching now the email and no the username and we'll make it accessing to our data base inside try with db_client. in local . in user. and now we gonna try to search it with find_one() we gonna try to search if it really exist how we made before to search for id in up where newuser up of put operation where we pass it to search the id in the find_one(the scritery we pass it equalm that there up here in the find_onem but we dont want that the critery be the id we want tha be the email without the _etc "email": email and we gonna search by the camp email that email) and with this it's already and what we'll have that to make in the db_client of here down is to end returning 
    #filter is called funtion of superior order, filter pertenece to a of the funtions that is build in and is of superior order because it encharge of to do complex operations and give back a result
    try: #En try start all the drive of the exceptions
        #what we'll have that to make in the line of db_etc is to end returning we could to say we've th user_search_Foretc but this must to end returning of some one way an user by that we return the db_client inside try for what we know if it really exist or not or we might return only True or False by example but in this case we gonna return all the user since is a search well that gives us the user and what lack us here is a transformation what is is in up inside async def user(etc) in line new_user in there we'd already the user_scheme in what we can to perform a transformation that we can to call it and then we copy that user_scheme(to transform it in here what we wanna transform) then to that db_cletc we transform it and we made it inside try becasue if that gets fail if it doesnt find and we'll pass it some one wrong data what be this try directly release us an exception and it goes away by the except: of down saying us the message and it's already doesnt happen nothing simply we try to control the exception because if not this might to make that our server petara of some one form here in the tryn the only that we're making is saying that if it's not capable of to find em if it peta of anyone way well it didnt find it and it's already all of return of try or be from scheme(untill inside here ) in really would be the user therefore we equal all of shcheme() to user= then we end it returning how an user our model or be the User(that user that once that we've already all the camps of that dictionary simply if we pass it in that User(**user) with that it'd be already or if we want we divide it and we make the user_scheme() we pass it inside User(user_scheme(**user)) the first to search it in data base or be in the line of up user= etc and after if we've it found we already perform the transfomation inside the return User with scheme to the dictionary and we sreate the object user or be the funtion of up user_search_Foremail this mean that we've already an operation that is capable of to say us if that user exist or be this funtion user_seaetc well then the user_search no more of up in post operation in other operations of get by example we can it already to come back to call we could to put this operation user_searchForetc in those parts instead of the before for to say search if really exist that user but not nor by if not by email because we said so
        #and with the new implemented this it'd become in more generic 
        user= db_client.users.find_one({field: key})
        return User(**user_scheme(user)) 
    except:
        return {"error":"didnt find the user"} #we can also return an json with a dictionary and his gonna be in the server#in except we do return of vacume, in this the server gonna give back the "" 

# we've all this already and we gonna delete someone comments because here they've not the same sense that before now the only that lack us is in the main what we must to make is to add this new router fo here or be the user_db file for that we import it in main 

#remember to put id int why if not the server peta since up the id is a int
#def user_search(id: int): #we gonna create this operation that we passed it and id and it returned with nothing "" simply for what it doesnt pete and we come back to get run the server and we gonna see the thunder client and it comes back to insert us it the same for see in what part is bad we can to use print or be we print the user in this case we print the user in under user = in search_userForetc in try: and we save it to see in the thunder client bu also in the part same of down in the terminal appear us a None when we send it in the thunder client is to say it's not us found the email how such in really is failing us the search and then we print the email in the same place and we send it and if we've the email in the terminal appear when also we send in thunder yet it's not finding it us well the reason because it's not working is because we're searching in user no in users or be in the user = line in the part of user there it must to be users no user is very important the nomenclatura other thing that was bad what transformation in the try of user_searchFoetc it must to put the ** start of user_schemetc  and no (**user) because we 1rst obtain the dictionary and after we encharge of to perform the transformation with the datas of the dictionary to the user that is all remember that this only work for the email so what if you put the same username dont care the thunder client only care the email and by end when we send in the thunder client a repeated email then the thunder sends us the message of error that we puts if there's someone problem with the users repeated already inside the data base then in the users file of mongodb we left click and select drop collection and in the local file left click also and we select in refresh is to say we cargar us that data base and with these selections but to the revez because was 1rst the refresh in local file and after in users we select drop collection and we put in the part of up that appear us we put the file that we wann delete and with the enter and then it dissapear then in the users file document dont gonna have the users inserteds and we dont have already a data base of users iif we want in users file again we left click and select drop collection we say it that we want cargarnos the collection of users and we end to delete that data base there in the mongo now we insert others to test in the thunder client and again appear the user file with the new users inserted and now if we try to insert it again with the same email it doesnt insert it and now what we've inside our data base comes back to be the documents that we inserted it doesnt allow already to insert duplies in base to the email and if we push those files inserted we can to verify that hasnt the same email we've controled that part at least any one user that we're it sending with the same email send us the message of error and ready with this we've the operation more complex prepared now we gonna go with the rest of easy operations imagining that we wanna obtain all the users of data base we gonna sii the easy  could to be if we wanna user obtain all the users of data base in the part of of get operation under the user_data_base = and up of get("/{id}") also is in under router = in this file and in the return 
    #return ""

#we were riding a mongodb in local is to say a data base no relational in local we start to work with it we were capable of to connect to it of to see that was saved in the data base of to make requests to our api and what already it was saving things etc so what if we remeber it simply by to give it an eye we've created by client file in db folder a client of data base nothing more even we said good well how can to get run the data base what we'd that to install and all the ray baswly in ther we'd all  
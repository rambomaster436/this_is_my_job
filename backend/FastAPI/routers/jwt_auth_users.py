#fichero for the authntication safer with the token jwt or be encripted oauth type bearer

#It's seem to the other type of authenticationin basic 

#we import the same that the the fichero basic_etc because we gonna us the same almost #we import APIRouter instead of FastAPI for do that when we run it get run absolutly all the apis that we've created how in the user we did it
from fastapi import APIRouter, Depends, status, HTTPException
#from fastapi import APIRouter, HTTPException 
#we import the BaseModel for the fichero from pydantic 
from pydantic import BaseModel
#we import for security the 2 auth the first for the password and the user and the next for the form in what the backend gonna capture that user and key
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
#import jwt from jose, also we import JWTError to capture the error in the funtion auth_user 
from jose import jwt, JWTError #also we could to import all the part of encriptation
#we import from the library passlib.context accessing to its context the class CryptContext this is for do the right encriptation by itself in crypt , this is almost like an algoroithm of encriptation, because it'll be what we need to to define the context of encriptation in crypt
from passlib.context import CryptContext
#we import datetime for the date of the system and timedelta to work with calculates of date from datetime and we gonna calculate in up of return in operation access_token in /loging which would be the moment in the what this token we give it how bad 
from datetime import datetime, timedelta

#algorithm of hash
#we gonna use and define here how if they were a constants the algorithm of hash 
ALGORITHM= "HS256" #the algorithm of hash we name it hoe ALGORI... following a bit the documentation the algorithm that we gonna use of encriptation that if we go also to the jwt in google we see that the algorithm see that there's differents to work with jwt and the most used is the "HS256"and we gonna say that the algorithm that we gonna use is this between "", once we've this will have that to start to see how we can to work for what this password that has us reached in the formulary we'll have to encriptar it because we'll have that encriptar it or desencriptar it depending but in really what we makes is encrptarla because of the what it try this is that these algorithms of encriptation abitually how it work is what we are capables of to encript and to match if in really coincide with the root that we are passing it we gonna pass it the password equal that before but in our data base we wont have yet saved the password the what we'll have saved in this data base will be the password encripted so what we'll have that to search 1rst how to verify this password it doesnt serve us already the comparation of down like form.password ==user.password we gonna implement some one operation to know if this password it has verified or not and for that is for the what we'll have that to define which is our context of encriptation in this case we puts crypt 

#ACCESS_TOKEN_DURATION=1 is for stablish the time of duration of the token for the time that to last the authentication and we stablish it its time in minutes in this case 1 because now we gonna have that calculate and to say part of the access_token and of to indicate it that its type is bearer this access_token gonna be now of type jwt in return of /login the jwt has many encripted parameters and one of those parameters gonna be untill when is valid that token and our system gonna be capable of to valid it and if we pass it our token in the moment that the system it encharge of to check untill when is valid if it's not already valid the system gonna says unvalid token generate me another because it passed you the time to generate this the 1rst what we must to do is to calculate in base to the hour that is in this moment when will be the date and the hour of expiration for that we import from datetime the datetime for the date of the system, and timedelta to work with calculates of date all this to work with dates 
ACCESS_TOKEN_DURATION=1

#secret is the key for what in the process of encriptation gonna use this that only we know this key can be anyone thing 
SECRET = "201d573bd7d1344d3a3bfce1550b69102fd11be3db6d379508b6cccc58ea230b" #we can generat a secret whatever # if we wanna generate a secret there's a way it's in the documentation of fastapi inside security in OAuth2 since now we've the library openssl ran -hex 32 or be of way general with iterm if we want if we access to the library openssl and we say it return me a number random rand of 32 in hexadecimal openssl rand -hex 32 and openssl is one of the libraries that mark that standar of security and it generates me eith that a set of words and numbers but gives equal that it generates and we put it in the secret= "here" once we have it then we pass to the parameter in return in /login in parameters of the encode how 2nd (, SECRET)

#remember to create the instance of the aplication to what work this
#instance of the aplication #APIRouter() is for what the instance of aplication 
#we change the app to router to do the operations 
router =APIRouter() #where we were using the app we change it by a router to let all coherent and in the main file already the last that quiet us was add these routers down of the router in main the last that quiet us was add the routers inside the file main we add the routers of here and the basic_auth so we runnig from an only site our server it gonna wake up all the projects that we created the routers added are so app.include_routers(products.router)

#the authentication by password we gonna continue using we gonna continue using by user and password and we gonna start to work with criptographia because the token and the system of authentication gonna be much surer 
oauth2 = OAuth2PasswordBearer(tokenUrl="login") #we gonna continue having endppoint called login besides that the token and the system gonna be safer 

#context of encriptation crypt 
#for the context of encriptation we need because we gonna work with another context of importation with other library that we've installed the passlib to import from the library passlib.context accessing to its context the class CryptContext because, this is a operation know if this password it has verified or not for that is what we'll have that to define our context of encriptation
#our algorithm of criptographia gonna be the "bcrypt" that work of a way very concret but how we've imported the library that contain this algorithm we dont need no to know how work it it'll encharge of to do the right encriptation once we've this the what we gonna can to do is verify if really the password that has us passed if really is the password encripted that we have saved the way in what we can to do this 1rst is to save the encripted password in the password of data base so what we must to go to the bcrypt in google and we go in in link Bcrypt-Generator then we put our password in the cell of Encrypt under Encrypt some text and we push the button Encrypt and it'll encript it in the green of up a encriptation that just the encriptation algorithm know and this is what we gonna save in the data base when it gives of alta the user it would encriptaria and we'd save it and so some one that reach to the data base go already with encriptation algorithm and this algorithm of encriptation only gonna know if it correspond with this if really we pass it correctly how is the original password because is capable of to encript but dont make the part of desincriptation, we gonna pass the encripted password created in bcrypt in google to the password instead of the before for the 2 passwords for that we encript the 2 and we pass em to the 2 passwords so we get in our data base no one reference to our passwords clear #all what is doing it is the library of encriptaion then we gonna under user = in /login where before we compare the passwords and we verify if these passwords are rights or not 
crypt= CryptContext(schemes=["bcrypt"]) #CryptContext will be what need to define this context of encriptation() it needs an scheme or schemes that define the algorithm of encriptation that we gonna use by example we gonna use "bcrypt" (schemes=["bcrypt"]) and so we have the algorithm of encriptation, inside of this algortithm we could pass it more things this has much more things inside object that gonna pick by here forward but by now we let it so with the parameters 

#concepts of encriptation that is in the documentation of fast#in documentation appear that the token jwt need differents dependences the 1rst we must install python-jose that fonna serve us for work with authentication type jwt "jwt mean JSON WEB TOKEN" #we can read also about the especification in google like JWT in there we can read also or to search about the especifications that is some how we dont understand is encoded and what in really the what gonna have inside are differents parameeters like the name of user and is some that to the desencriptarlo we can to access to it but in really what we gonna be passing instead of the what we put gonna be of the type of the JSON WEB TOKEN seeing how it generate and how it manage by that we 1rst install the dependence that we need how the pyhton jose remember stop the server frst and we install the library of criptografia pip install "python-jose[cryptography]" by other side the documentation need install passlib because the algorithm of encriptation that we gonna use that is this "bcrypt" is inside this library all this libraries are in FastAPI google security OAuth2, once that we have that installed untill can start to import em like from jose import the jwt and also we could import all the part of encriptation 

#we import the same that the part for the boject user of data base from the class User untill the final of the elements of userses_db from basic_auth etc we reply for what all quiet separed then we must stop the server uvicorn in basic_etc and run it in jwt_auth the server 
class User(BaseModel): #the BaseModel gives us certain mechanism for what this object that we defined how a class it can to pass throuth of the net of a way very easy and it can transform in a json of there it can transform to a class and to the final we cn to work in python and by other side sith all the protcole http what we have mounted for it the o down
    username: str #
    full_name: str
    email: str
    disabled: bool #disabled is desactivated bool only accept a 1 or 0 or False or True

class userDDB(User): #this is the entity that represent to the data base user and is of type User
    password: str

userses_db ={   #once we have an object that has these datas surely these data bases has that to be saved of some one way so what we gonna create all the elements of the data base and define em how they'd be and we add one more 
    #remember the username in thunder is the name of the list keep seems
    "mouredev": { #this is a list an array of differents users that this is representa the data base 
         #datas of user 
        "username": "mouredev", 
        "full_name": "Juanpapiriky",
        "email": "Juanpapiriky@gmail.com",
        "disabled": False,  #For if is disabled or not, this is very typical when we're working with users in data bases because any times the only what we wanna do is to put a flag that says this user is able or disabled beacuse he's deleted is restringed etc 
        "password": "$2a$12$Kva8GTpHy/jjBa1uMvuWLu8zaPkm0YXOBdihuFYrHsay.HzkhLFZq"   #the passwords here should be encripted that use some one hash or some one algorithm of aseo to can encriptar this     }, #this before was 4321
    },
    "mouredev2": {
        "username": "mouredev2", #
        "full_name": "layout",
        "email": "layout@gmail.com",
        "disabled": True,  # we change this False for a True for what this user is disabled #with dissabled in True say us that the user is unactive #the dissabled mean that the user is disactivated or dissabled 
        "password": "$2a$12$VPKx2JIOrtP/q1IAc1F/HusRjtrK3bDoiM5AzqdjXNoRVwC1tgtKq"  #in this we gonna start to work with authentication #this before was 1234
    }

}
#in this code all is equal except the password than the security standar basic or normal in this case the password gonna be some different 
#this is for what work the code 
#operation of search of users 
def searchUser_db(username: str): #with this it connect with the server or be the parameter 

    #For to search if we have the user in some one side is to run all the data base with if 
    if username in userses_db: #what we are finally doing here is retreiving the user and we gonna return it
            
            #with the return we can search already it #of this way we've transformed that critery in an user of data base with this we can obtain already
            #when we try of to post the username and the password in /login thunder body form it send a internal server error a 500 or be this has petado because this is not working no matter if you send the user.. right or the pass.. eveny it sends us that that is because it is failing in this creation of down by that we put the ** in (**userses) once puts this this gonna work and gonna return acces_token and a token_type, to do this call to create it the UserDDB here we're not saying it in really how it's that to create simply is a class with the BaseModel we're indicating nothing more is to say that we can to send em differents parameters and with these ** we indicate the nmber abitrary of parameters how it's that to create the UserDDB(User) the inside BaseModel funtion that is not in this module the representation metaclass=ModelMetaClass in really we could to pass it a huge of parameters by that we must indicate it what in userses_db can to go severals now it'll work well 
            return userDDB(**userses_db[username])

#this is for what dont return the password 
def searchUser(username: str): #with this it connect with the server or be the parameter 

    if username in userses_db: #what we are finally doing here is retreiving the user and we gonna return it
            
            return User(**userses_db[username])

#This user in current_user(token) in the token when we reach in there what we gonna have before we had an user and what we wanna end obtaining is the user instead of the token (user:str =..) because the token this token: str is what we have that to end obtaining of the auth_user so what we put that (token: str) inside of the auth_etc of up so what 1rst we the auth_ what we want that give us is an User (user:User) so what the critery of dependence what return me is an user and down is where we can to do the comprobations   
#this operation critery is to see if we can find the authenticated user
# the important would be to know if now here with the token we're capable of to find it the dependence here gonna be in token: str = Depends this gonna have token a dependence when we reach to the token the dependence was already of our authentication system that was oauth2 =Depends(oauth2)now then we can already to pick the token that was what was in jwt google Encode but it wont value because will be expired but imagine us that is that what we'd have that to do if we come to thunder in the operation get /users/me in Authentication Auth of down was a token of type Bearer in down of it we put in Bearer we'll have that to pass it that token of before in the Encode if we send it it return me a error because we're still implementing it, we've the token and what we've that to do with it is to desencript it is to say we'll have that to obtain in base to that token the datas of jwt in google all of down of Decoded because in those datas is where we can end getting out the user by example and so ending and so to search it in data base if this token has been passed of hour well the system dont gonna valid and we go to down in user = in this operation that we create by the user 
async def auth_user(token: str = Depends(oauth2)): #auth_user is a dependence for search to the user and we put in in the funtion current_user in the =Depends(auth_user) 
    
    #exception we copied of raise its inter for what be equal to the class HTTPException
    exception = HTTPException( #we copy this to the others to save space 
                status_code=status.HTTP_401_UNAUTHORIZED, 
                detail="credenciales de autentcacion invalidos", 
                headers={"www-Auhtenticate": "Bearer"} )

    #try: for drive the Exceptions 
    #try except is for capture the Exception 
    try:
        #going by the user in user 
        username = jwt.decode(token, SECRET, algorithms=[ALGORITHM]).get("sub") #in user we've the token that is all the token jwt doing it the encode equal that before we did it the decode jwt.decode() but to do it we'll have that to pass it the token in encode(token) with the criteries to do the decode or be to pass it (,SECRET , algorithm=[what we defned up of type HSetc ALGORITHM]) is possible that here we've the datas of the user of all these datas we should to test 1rst if in these datas is the name of the user by that we make a after of the rest.get() of one of the parameters that has this json the name of the user was a parameter that we've saved how "sub" in the Encode google jwt then for us the user in really would be the username so what we change it then if this work we would be capable of to have in username the name of the user but this can release an Exception can to end petando so what we gonna catch the Exception with try: and except: in up and down 
        
        #ensuring what the name of the user is not none by that we do the if not 
        #if it doesnt go in by here it wanna say that we've reached to the user is to say that we've already the information of this user or what we've the name of the user once we've already the name of the user the what will lack us is to obtain the user, all this has gone well and the form in the what we'd to obtain which is the user is the of basic_auth_etc the def searchUser that search the user and to create it with the of data base but without complicate selves much we have an operation here also the of searchUser_db but was more difficult with that, this operation easier is for what this dont return the password we put this copied of basietc in down of the funtion searchUser_db how a new funtion 
        if username is None: #can be none because we didnt save it because is not in data base because the json doesnt have this camp etc imagining that the "sub" was vacume was none that dont gonna value in the case that this neither value also we'd have that to release the exception of raise that we copied 
            
            #launching the exception #we're repeating the exception of down and we gonna create a variable called exception up in the start of this funtion that is equal to raise
            raise exception
        
    #Except is for return the exception 
    #if it goes us by here mean that all this mechanism of up username that encharge of to search the name of the user has failed because it didnt find it because it hasnt been capable of to make the decode because it didnt find some one key that be equal to "sub" of Encode in google that mean that has petado equal has worked and it didnt release an error then we say it that is well and here in case that give us an error then we could to say it that this has failed so what we copy all the operation of if not user: only the part of raise or we can just delete the "if not user:" is easier and we put in in except JWTetc: to release the exception that we're trying already before in the user of type basic and in the case that this work we gonna ensure of what the name of the user is not none in up try: we do in try by that we go to try  
    except JWTError: #the error that we wanna capture is JWTError and this is inside the library that we must import from jose like JWTError  
        # if has the user we return it if hasnt it then we'll launch an exception well concret with its headers that is not used
            raise exception
    
    #if we really reach to this point and it hasnt or didnt happen no one exception then it wanna say that we can return the user or be searchUser() passing it the username (username) and with that we've already the user, where we're calling to auth_user is in current_user 
    return searchUser(username)

#operation go searching the user of the setion 
#we gonna to put in it another dependence in Depends 
async def current_user(user: User = Depends(auth_user)): #we gonna put in it another dependence in Depends instead of the algorithm of authentication straightly oauth2 we put a new critery that we create up of this async def auth_user() and this serve for see if we're capable of to find the autheticated user 
    
    #the searchUser we also bring of up 
    #in the searchUser we still dont gonna have here the auth_user instead of the tokens of up and here we've before to find the token because this gonna work then we go to the operation get /users/me in the Depends 

    #doing testings 
    #if doesnt exist the user this part of if not user we move it the operation complete for the funtion of up auth_user because it'd be more for that because here how we gonna have more to the user we might to test only if it's dissabled this would be that 1rst critery or be this funtion current where would be the important would be to know if now in auth_user with the token  in auth_user we're capable of to find it it also has a dependence  
    
    #we have some bad still by here that still we were not capable of to create an user ho such so what we'll have that to search the way of to create an user and create it that be of type User that dont be of the type userses_db
    #this is for solve the problem of that return things that dont should the /users/me 
    #imaging if the user is dissabled then we can to put another error 
    #here the user it's been found but we convalidate if the user is dissabled then we could return an error in this case a 400 because is a bad request in detail we put unactive user also to have in count that flag and in case against return the user  
    #here we've the user and we test if is dissabled or not but if no we returned already and we can already give back in the operation /users/me 
    #if user is dissabled then it sends the error 
    if user.disabled:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="unactive user")
 
    #returning the user if has been found the user 
    return user
#implementation the operation of authentication basing in the all the before of basic_auth the app.post /login modifieng it to what it adapts to the jwt 
@router.post("/login") #in this operation is of type authentication where we pass it user and password by that we use the operation post that ussually it use because we gonna pass it datas to gets datas the URL where we gonna expose this operation of the api is the login

async def login(form: OAuth2PasswordRequestForm =Depends()): # we capture a parameter called form: what gonna be of type OAuth2PasswordRequestForm or form and the next important is what we gonna say it that the OAuth2PasswordRequestForm by defect gonna come of Depends(): for that we import Depends from fastapi together with FastAPI depends serve for when we have that to see if the parameters how if we area authenticated or not for to access to the user or if we can to do some one thing there is where go in the depedence by example the dependence for modify datas gonna be that we're authenticated or not and what are authentication with the credencials rights or be more or less how and if it work in our case this depends mean tht the operation gonna receive datas but dont depends of no one 
     
    #we must to do one step more the password that reach us by here we must to start to test if is encripted or not the 1 what must to do is to pick the operation form basic_etc searchUser_db  of searching of users in up of operation post 
    user_db=userses_db.get(form.username) #once we've form.username can we start to test if really we have an user with user_db or be we gonna search in our data base if really is this user without to reach to transform it that we get with users_db.get(form.username) with the get we really search if is that user 

    if not user_db: #if doesnt exist the user posted then is not in the data base  
            
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="el usuario es incorrecto") #launching the exception in this case and sopping the execution with the raise it can and the status code we defined it how a 400 the message is what the user hasnt been foundwith that we have a ewxception catched

    user=searchUser_db(form.username)#here we have already the user or it return the user with this operation they give us the user if pass the others conditions in parameters goes the (form.username) for what now if return the user

    #we verify if the passwords are rights or not and we'll make it of the next way once time we've already the user and we've our context of encriptation crypt. we've an operation called verify and in this operation we can pass it the passwords by a side the original password or be the what comes in the formulary the form.password and also to pass the encripted password the what is in the data base this user of data base that we've retreived here in base to the user user.password once we've this what does the verify is to say us if really has been capable of to verify our password in original plane or be the original password with the password that we've saved encripted and the way that we'll make this is putting this with the if not of down instead of the form.password = etc because is easier 
    if not crypt.verify(form.password,user.password): #if not verify will mean that we didnt authenticate self correctly and in detail it says that the password is not right because it doesnt coincide with the encripted password in case right we're authenticated already after now we need to generate a token in the return 
        
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="la contraseña es incorrecta") #launching the exception
    
    #operation access_token_expiration is for calculate the moment in the what this token we must to give it how bad this will be the actual hour in what it generated the token adding it the time that we've told that to last the token or be 1 minute we put the funtion timedelta with the parameters of the or the call minutes= we pass it the constant ACCESS_etc of up under import 
    #access_token_expiration is for the time of expiration 
    #access_token_expiration = timedelta(minutes=ACCESS_TOKEN_DURATION)#The ACCESS_TOKEN ETC is to do the time of duration of the token with that the access_token_ etc gonna create one delta that be 1 minute more above what we've with this we've the time , all this should to have more things so what we gonna start to create differents parameters in down, one of the parameters that we want that carry my token jwt parameters that get loose to pass ever is when expira in down we put it the expire#all this module has that to be at final some encripted that contain the data on here that inside also must to contain the datas of the user so what it should contain more things no only this 
 
    #access_token is for define the access token the access token  that we gonna just encripting it this gonna have inside are the camps "sub": that is the user the name of the user user.username these we put inside of the sets how a dictionary {} another is the expiration date the expiration date of a token gets loose represent with "exp": and it expired with the operation expire#the access_token gonna end being some encripted but initially was a json the seen in the jwt in google is a json rememeber jwt is json web token 
    #expire is the parameter that gets loose to carry 
    #expire is for when expira #we do it putting the date of the system datetime. the utcnow is for call the hour of the system + the delta operation or be we call to timedelta(minutes=ACCESS_TOKEN_DURATION)
    #expire= datetime.utcnow() +access_token_expiration#this gonna expire just the actual time more 1 minute with all the operation delta ,this also has that to carry inside the object own jwt we may to pass more datas like user name of the user #we see the parameter for the name of the user in the jwt of before in this we see it in decoded payload the sub nam and iat the sub makes reference to the user of the token that itself is authenticating we gonna work with these parameters the sub represent the name of the user, name is the user in itself and when it gonna caducate so what we gonna create an object that gonna define already the access_token that we gonna just encripting it down we define how variable access_token

    #access_token is for define the access token the access token  that we gonna just encripting it this gonna have inside are the camps "sub": that is the user the name of the user user.username these we put inside of the sets how a dictionary {} another is the expiration date the expiration date of a token gets loose represent with "exp": and it expired with the operation expire#the access_token gonna end being some encripted but initially was a json the seen in the jwt in google is a json rememeber jwt is json web token 
    access_token = {"sub": user.username, 
                    "exp": datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_DURATION)} #our access token gonna have the sub with the name of the user and when it expires once got this we put it in the return instead of the user.username in its access_token: for return the access_token created

    #now we need to generate a token before we passed it the user but having in count that we've an user that is encripted its password and we return that the token is mouredev then it'd be bad because it following being unsure also we must to generate an access_token of way sure we must to create an authetication of way sure  
    #the concept of authentication the concept of access_token has asociated a duration of the token when authenticate yourselve you dont gonna authenticate forever if no a days a hours in the part of up in under the ALGORITHM we put the time that gonna to last the authentication in this case 1 minute how it puts the time is with ACCESS_TOKEN_DURATION=1 that 1 is the minutes 
    return {"access_token": jwt.encode(access_token, SECRET, algorithm=ALGORITHM), "token_type": "bearer"} #we change the user.username by the variable access_token to return and now we go to the thunder in /login under Body we put the Form and we put the username and the password in the Form Fields and we authenticate self in those 2 username etc and we send to authenticate selves the rights of up that were first before to put the password encripted remember to open the server for this file, and it'll return the access_token with its sub, exp or be when it expire its date how "2023-07-25T04:22:06.278443" where the first is year-month-dayThour:minute in reallu this goes with the hour UTC we're one time more in another place this is working with hours that gonna work in anyone use horary because it gonna work ever in the same user is an UTC is to say that after keep where you're gonna do a calculate in concret with your horary and the machine then it always gonna have the same horary this mean that no why we're in differents countries this we gonna can lie the exp of thunder this is working with the UTC the UTC in spain by example is UTC+1 by that says in spain 21:01 expire because in the video it has generated to the 22:00 spain hour that is the 21:00 UTC and gonna end the duration of the token 1 minute after but we come back to have the same that of the response is a token before we had a token that only says mouredev then it mean that we must to pass all that new of the response in thunder to other operation to can authenticate self no by that we need a token that got is not a token if no a json super complex that should save well such how it was to pass it dont value for nothing the plugging vc code show you how end a key now vc code has already it of way native is one of the of the options though is saying there rainbook brackets we dont use already it because now of way native it's already it is an option that you can activate to search which is the name of the action of the option and you activate it is an option experimental that still is not how definitive we search it and we gonna find it quickly, lack some more in the part of authentication in return we're returning the token such which acces_token but this should be some encripted then we gonna encript it with a library capable of to work with jwt or be the imported jwt so what we put in it in the return instead of access_token jwt. and insidse this we have how to do the encode and the decode in this case we gonna make the funtion encode() and if we wanna make it we must to pass it of the what we wana make the encode or be of our (access_token) with this might to be enough but the algorithm that we gonna use that is the variable ALGORITHM is good to know in what we're moving selves because after we gonna have that to work with a encripted token that we'll have that desencriptar to test if the things are right or not the algorithm that we wanna use is the algorithm HS256 with that is very typical to work this is in the jwt google in up of Decoded is it Algorithm wew add it in here the parameters of encode (, algorithm= the variable ALGORITHM) #another form safer of to work is with a secret is to say with a spice of seed  what we can generate that only know our backend and what so it does that that encriptation and decriptation use already a seed that only we know and that it gonna do that be safer because in the process of encriptation it gonna use a key that only we know so what in under of ALGORITHM and ACCESS_TOKEN in up we create a variable SECRET for this we put a secret there whatever, now with the SECRET gonna do in the moment that we release the encode it gonna go much better now we've a token that gonna be some encripted that just we know  with that gonna serve a little more then with this we go to our api in thunder gonna call it and authenticate selves inside login how the before we did it now we'll have an "access_token" with some encripted that nobody know that is and we may to go to the page of jwt and tp come by the lowest and push the secret base64 etc is to put it in base64 and we see the next we've an algorithm in the header of type jwt and the datas that has the algorithm the token are sube or be the user and the time of expiration it says the hour and when it expires and all inside a token now we've already a token the what is inside Encoded we must to save to call to our api all get copy it and this is the what has that to end driving of someone way this is the important now the we've this it lack us the same that we did with basic authentication and now how we drive a token for that we go to the file basic_auth etc in the last part in operation get("/users/me") and we copy it all that operation to obtain my datas and we put it in down for do that operation 

#operation to obtain my datas 
#here is where goes in the dependence algorithm current_user  
#we put up the operation of current_user or be the algorithm of dependence we copy also from basic_auth etc this we put under def searchUser_db this in the basic_ under def searchUser() 
@router.get("/users/me") #get("/user/me")this path is for what once authenticated us what's my user 

#this get had a dependence Depends but is not enough, and we gonna see how we'll can to find this user and we go up in async def current_user to change the token in there 
async def me(user: User = Depends(current_user)): #the algorithm of dependence is some that we call current_user this search which was the user of the setion 
     
    #implementation if really we can obtain to this user inside of the implementation
    return user

#we gonna test all this in thunder we put first the /login we gonna in Body Form and we pass it the right user and password we release and we copy the token of access_token eithout the "" and we gonna try to call to the operation that return to the user or be /usersetc and we copy the token inside of the Auth in Bearer how a token and we release it and obtain the user in the response ,a extencion how postman but for vc code is the thunder client, and with that we got authenticate the user we've called /users/me and we gonna see what it did 1rst dependence current_usetc next dependence user_auth we got the token we desencript it get out the name of the user in the moment in what we've the name of the user we searched it and return it the operations of auth_user is how the process of validation of token we gonna wait how much duration had this token that was 1 minute that was puts by us this wanna say that in the token when we've generated it in thunder wait 1 minute we come back to release it gonna give give back error the message of invalids credentials or Connection was forcibly closed by a peer. because we released it in funtion auth_user when there was a error to the hour of parsear or when there was an error that we're not already capable of to pass it the token that was the token of thunder before of 1 minute it doesnt work already because has transcurred the time the time of expiration that we've given it and how form part of the own standar jwt the time of expiration is already capable of to control it and it says that there's an error this it doesnt give it parseando and it release already you an error so what in tunder we repeat it to add more time or be we make the same of before to retreive our datas or come back to work and so we do it every time that expire the token remember who expire here is the token and evertime that exppire obtain a new completely different this is a mechanism a little more advanced of authentication what is what to the gernerate a token also it gives back a refresh token this wanna say that we with that refresh token the own aplication could to request a new token without authenticate self to hand is to say in the moment that fail the authentication the aplication by of down with the refresh token that is some that also know the backend it can it to say that we authenticate selves before we can to follow authenticating you can to give us a new token this it does for what though somebody has the token in general how they hasnt the refresh token might to supplant you your identity by example during 1 hour that we gave it of validez but in the moment that end is how to give inside the security of the token encripted a extra of security that is what we gonna make that caducate and how only the user have the refresh token only the user gonna be capable of to valid it and of come back to generate it again 
#we created these 2 apis of authentication the of basic_ and jwt_ one a little more basic and other with jwt but the only that we wanna make is before nothing is what we create simply an api by separed but equal that we did before that we'd a router the what we wanna make is to pass all this to a router to what in the moment that we run our server get run absolutely all the apis that we've created this was very easy just is to go to the api of user oly we need to import APIRouter instead of FastAPI equal that in the users file we did and we make the same in app we put he APIRouter 